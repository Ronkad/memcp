MMap
----
import "https://github.com/edsrzf/mmap-go/blob/main/mmap.go"
mmap.Map(file, RDWR, 0) // oder RDONLY
// available functions: Flush, Unmap
// ist dann ein byte[]

runtime.SetFinalizer(obj, finalizer(obj))

TODO
----
 - SELECT DATABASE()
 - UPDATE & DELETE parsing
 - session-local storage for mysql session state (variables, current schema)
 - per-table persistency settings
 - (scan db tbl condition map reduce neutral) -> aggregates, unordered fetches
 - (ordered_scan db tbl condition map reduce neutral order limit offset) -> items are sorted before given to map; reduce is not parallelized
   algorithm:
   	1. parallel select on each shard
	2. every selected recordId is pushed to a shard-local heap-stack (with orderfunction)
	3. create a global heap-stack; push the least item of each shard onto that stack
	4. while items are left on the global stack:
		* pull from the global stack (and remember from which shard it was)
		* if !offset--: agg = reduce(agg, map(item))
		* push the next item that was popped from that shard
		* if limit is reached, return item
	--> possibility to optimize by parallelizing map (but limited to limit+offset)
 - (grouped_scan db tbl condition groupfn map reduce null reduce2 null2) -> temp-table
 - temptable -> createtemptable(columns)
 - queryplan builder:
 	-> turn all subqueries into LEFT JOINs
	-> merge all join'd tables with the same condition
	-> join order
	-> scan generation
 - joint-scans (equi-joins with cached last-index positions)
 - scan -> only "go" those shards that have the value range within (in an optimized data structure because there can be thousands of shards)
 - scm.Verify(expr) -> static code analyzer: exact number of parameters, minimum number of parameters, parameter types (function, dict, string)
 - line numbers and filenames -> wrapper for []Scmer that has to run .Verify??? SYMBOL [debug]
 - documentation (-> structured data from Verify)
 - docker + docker hub
 - mysql importer
 - plugin concept e.g. for AIs (they will declare new scheme functions)
 - user management tables (users, grants)
